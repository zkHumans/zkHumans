import {
  Bool,
  Field,
  Poseidon,
  PublicKey,
  Signature,
  Struct,
  UInt64,
} from 'snarkyjs';

export { BioAuthorizedMessage, ProvableBioAuth };

/**
 * A message bio-authorized by a human then signed and timestamped by the
 * BioAuth Oracle.
 *
 * @class BioAuthorizedMessage
 */
class BioAuthorizedMessage extends Struct({
  payload: Field,
  timestamp: Field,
  bioAuthId: Field,
  signature: Signature,
}) {
  /**
   * Return a BioAuthorizedMessage created from JSON data.
   */
  static override fromJSON(data: any) {
    return new BioAuthorizedMessage({
      payload: Field(data.data.payload),
      timestamp: Field(data.data.timestamp),
      bioAuthId: Field(data.data.bioAuthId),
      signature: Signature.fromJSON(data.signature),
    });
  }
}

/**
 * Collection of utility functions for crypto-biometric authorization in the circuit.
 *
 * @class ProvableBioAuth
 */
class ProvableBioAuth {
  /**
   * Verify a bio-authorized message (signed oracle response) in circuit.
   *
   * @param {} oraclePublicKey The BioAuth Oracle's public key
   * @param {} oracleMsg The message signed by the BioAuth Oracle
   * @returns {} True iff the bio-authorized message is valid
   */
  static checkMessage(
    oraclePublicKey: PublicKey,
    oracleMsg: BioAuthorizedMessage
  ): Bool {
    // Check whether the signature is valid for the provided data
    const validSignature = oracleMsg.signature.verify(oraclePublicKey, [
      oracleMsg.payload,
      oracleMsg.timestamp,
      oracleMsg.bioAuthId,
    ]);

    // Check that the bioAuthId is not 0
    const validBioAuthId = oracleMsg.bioAuthId.equals(Field(0)).not();

    return validSignature.and(validBioAuthId);
  }

  /**
   * Verify a bio-authorized account (Mina PublicKey) in circuit.
   *
   * @param {} oraclePublicKey The BioAuth Oracle's public key
   * @param {} oracleMsg The message signed by the BioAuth Oracle
   * @param {} userKey The human's public key
   * @param {} userSig The human's signature (signed public key)
   * @returns {} True iff the public key is bio-authorized by the human
   */
  static checkAccount(
    oraclePublicKey: PublicKey,
    oracleMsg: BioAuthorizedMessage,
    userKey: PublicKey,
    userSig: Signature
  ): Bool {
    const validMessage = this.checkMessage(oraclePublicKey, oracleMsg);

    // Check that the user owns the user key
    const validSigUser = userSig.verify(userKey, userKey.toFields());

    // Check that the bioauthenticated payload was generated by the user
    const validSigHash = oracleMsg.payload.equals(
      Poseidon.hash(userSig.toFields())
    );

    return validMessage.and(validSigUser).and(validSigHash);
  }

  /**
   * Verify the TTL of the bio-authorized payload.
   *
   * NOTE: 2022-12-12 timestamp operations appear problematic
   *
   * @param {} oracleMsg The message signed by the BioAuth Oracle
   * @param {} currentTime The current network time
   * @param {} expireTime The expiration time of the bio-authorization
   * @returns {} True iff the TTL is valid (current and not expired)
   */
  static checkTTL(
    oracleMsg: BioAuthorizedMessage,
    currentTime: UInt64,
    expireTime: UInt64
  ): Bool {
    // Check that the current time is not before the oracle's timestamp
    // and not after the expiration time
    const then = UInt64.from(oracleMsg.timestamp);
    const validTimeLower = currentTime.gte(then);
    const validTimeUpper = currentTime.lte(expireTime);

    return validTimeLower.and(validTimeUpper);
  }
}
